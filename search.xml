<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CEOI2009 logs 题解]]></title>
    <url>%2FCEOI2009-logs%2F</url>
    <content type="text"><![CDATA[Problem问题简述：有一个$n×m$的01矩阵，现在你可以的任意交换其中的列，要求找一个最大的仅由1组成的矩阵。 输入格式：第一行包含两个整数$n(1≤n≤15000)$和$m(1≤m≤1500)$，表示矩阵的大小。 接下来$n$行，每行$m$个字符$0$或$1$。 输出格式：一个最大的仅由$1$组成的矩阵面积。 样例输入输出：123456789101112Input #110 6001010111110011110111110011110111111110111110111000101010101 12Output #121 限制时间限制0.6秒 空间限制64MB Solution算法这道题看起来复杂，事实上比不能交换列还简单。 先来考虑一行的情况。 显然，由于列可以自由交换，有多少个$1$矩阵就有多大。 可以理解为，把所有的$0$扔到最后，统计前面$1$的个数。 然后考虑两行。 仿照一行的做法，把所有上下全为$0$的往后扔，上下全为$1$的往前扔。 由于我们的目标是把能与下一行组成矩阵的列往前放，而 上$1$下$0$ 显然不符合这个要求，$0$在下面就隔绝了上方矩形继续升长的路。 所以把$01$放在$11$后面，$10$前面。 至于$10$和$00$之间的顺序，它们已经对之后的操作没有意义了，所以这不重要。 下面是一个例子。 如果输入长这样： 1210110101100110 处理完后就变成： 1211001101111000 可以清楚地看到最大矩阵大小为$4$。 其实处理时，我们需要的只有： 12111111 如果行数$≥3$，那么就按每一列下方有多少个连续的$1$降序排序。 于是每一个输入都可以变成类似于 12345671111111111111111111111111111111111111 的样子，接下来要求最大子矩阵就很方便了。 注意：处理完后的矩阵每行长度不一定升序，但这并不影响最后的结果 代码代码对之前的算法略作改进，详见注释。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXM = 1500 + 5;int n, m, ans;int q[2][MAXM], depth[MAXM];//q是滚动数组，用来记录上一次排序好后列的编号//depth用来记录当前每一列连续1的长度int front, top;bool x;char ch;int main()&#123; cin &gt;&gt; n &gt;&gt; m; //未经处理时，每一列都一样，q的数值就是自己的下标 for (int i = 1; i &lt;= m; i++) q[0][i] = i; for (int i = 1; i &lt;= n; i++) &#123; front = 0; ch = getchar(); //吃掉换行 x ^= 1; //滚动 for (int j = 1; j &lt;= m; j++) &#123; ch = getchar(); if (ch == '1') depth[j]++; //如果是1，深度+1 else depth[j] = 0; //如果是0，之前无论多少个1都不会对后面产生影响，深度记为0 &#125; for (int j = 1; j &lt;= m; j++) if ( depth[q[x ^ 1][j]]) q[x][++front] = q[x ^ 1][j]; //如果这一列为1，那么一定排在0前面 //从第1列排序好后，q数组记录的编号就是按深度降序排列了 //因为先访问的是已经有1了的，所以越早获得1就排在越前面，晚获得1只能排在之前就获得了1的后面 top = front; //depth&gt;0的最后一列的编号，计算ans时不需要depth=0的列 //把深度为0的塞进去 for (int j = 1; j &lt;= m; j++) if (!depth[q[x ^ 1][j]]) q[x][++front] = q[x ^ 1][j]; //从后往前搜可以优化 for (int j = top; j &gt;= 1; j--) if (j &lt; top &amp;&amp; depth[q[x][j]] == depth[q[x][j + 1]]) continue; //一点小优化，深度和你一样，宽度还比你长，面积一定比你大 else ans = max(ans, j * depth[q[x][j]]); //更新答案 &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 后记问题来了，这道题长得不像悬线法啊？ 是的，但可以理解为$left=1,right=\text{排序后列数}$的悬线。 Data暂无测试数据QAQ]]></content>
      <categories>
        <category>solution</category>
      </categories>
      <tags>
        <tag>CEOI</tag>
        <tag>2009</tag>
        <tag>悬线法</tag>
        <tag>滚动数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CEOI1995 stick 题解]]></title>
    <url>%2FCEOI1995-stick%2F</url>
    <content type="text"><![CDATA[Problem问题描述：乔治有一些同样长的小木棍，他把这些木棍随意砍成几段，直到每段的长都不超过$50$。 现在，他想把小木棍拼成原来的样子，但是却忘记了自己开始时有多少根木棍和它们的长度。 给出每段小木棍的长度，编程帮他找出原始木棍的最小可能长度。 输入：输入文件共有二行。第一行为一个单独的整数$n$表示砍过以后的小木棍的总数，其中$n≤64$，第二行为$n$个用空格隔开的正整数，表示$n$根小木棍的长度。 输出：输出文件仅第一行，表示原始木棍的最小可能长度。 输入输出样例：123Input #195 2 1 5 2 1 5 2 1 12Output #16 Solution显然这是一道搜索题。 由于每根原始木棍长度一样，所以答案必然能整除所有木棍总长度，并且不能比最长的那一根短。 搜索的结束条件是 剩下的木棍根数 $=0$ 且 当前原始木棍剩余长度 $=0$。 如果 当前原始木棍剩余长度 $=0$，那么之后的木棍就应放到下一根里去。 具体剪枝方案见代码注释。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 65;int n;int a[MAXN], sum;int all; //初始长度bool Visit[MAXN];bool cmp(int x, int y) &#123; return x &gt; y; &#125;bool dfs(int last, int left, int depth) //last表示上一次用了哪一根，由于已经排过序，这一次取的木棍一定比上一次短&#123; if (depth == 0 &amp;&amp; left == 0) return true; //搜完了，满足条件 if (depth == 0 &amp;&amp; left != 0) return false; //搜完了但不满足条件 if (left == 0) left = all, last = 1; //这根填满了，重置下一根 for (int i = last; i &lt;= n; i++) if (a[i] &lt;= left) &#123; if (Visit[i]) continue; //已经用过了 if (i &gt; 1 &amp;&amp; !Visit[i - 1] &amp;&amp; a[i] == a[i - 1]) continue; //如果上一根和这一根长度一样，也没能成功，这一根可以不搜 Visit[i] = true; //标记为已访问 if (dfs(i, left - a[i], depth - 1)) return true; //递归搜下一根 Visit[i] = false; //回溯 if (a[i] == left || left == all) return false; /* 已知放这根木棍不成功，那么分两类讨论： 1.若放好这一根正好能填满当前原始木棍，而剩下的木棍无法填满之后的原始木棍，则之后搜的结果和本次搜的一样，都无法完成，回溯； 2.若当前原始木棍是一根新木棍，则亦无法完成，原因同上。 这层剪枝十分重要，但较为难想。 */ &#125; return false;&#125;int main()&#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i], sum += a[i]; sort(a + 1, a + n + 1, cmp); for (int i = a[1]; i &lt;= sum / 2; i++) if(sum % i == 0) //能整除 &#123; all = i; if (dfs(1, i, n)) &#123; cout &lt;&lt; i &lt;&lt; endl; return 0; &#125; &#125; //找到答案 cout &lt;&lt; sum &lt;&lt; endl; return 0;&#125; Data测试数据 提取码：3gag 无注释代码也一起放了进去，供大家参考。]]></content>
      <categories>
        <category>solution</category>
      </categories>
      <tags>
        <tag>搜索</tag>
        <tag>DFS</tag>
        <tag>CEOI</tag>
        <tag>1995</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Balkan2008 closest 题解]]></title>
    <url>%2FBalkan2008-closest%2F</url>
    <content type="text"><![CDATA[Problem问题描述：有两个没有前导$0$的$n$位十进制数$A$和$B$。我们需要找到两个最接近$A$的$n$位数(第1个大于等于$A$，第二小于$A$)，包含B的所有数字。 例如，如果$A=3022$，$B=1232$，采用$B$的数字，我们可以得到以下$4$位数:$1223$，$1232$，$1322$，$2123$，$2132$，$2213$，$2231$，$2312$，$2321$，$3122$，$3212$和$3221$。 最小的大于等于$A$是$3122$，最大小于$A$的是$2321$。 如果$A=1232$，而$B=3022$，可能的$4$位数是$2023$，$2032$，$2203$，$2230$，$2302$，$2320$，$3022$，$3202$和$3220$。 最小的大于等于$A$是$3122$，最大小于$A$的是$2023$。不存在小于$4$的数。 编写程序，对于给定的$A$和$B$，找出最接近$A$的包含$B$的所有数字的数，或者确定其中一个是不存在的。 输入格式：输入两行，都是没有前导$0$的$n(1≤n≤60)$位正整数，第一行是$A$，第二行是$B$。 输出格式：输出两行，每行一个十进制数。 第1行是最小的大于等于$A$的没有前导$0$的，包含$B$所有数字的$n$位十进制数。如果这样的数不存在，则输出$0$。 第2行是最大的小于$A$的没有前导$0$的，包含$B$所有数字的$n$位十进制数。如果这样的数不存在，则输出$0$。 样例输入输出：123Input #130756604 123Output #140660 123Input #230002034562454 123Output #242445562655444 Solution本题难度不高。 很容易想到，既然越接近越好，那么就一位一位匹配，能匹配上就用，如果发现完成不了回溯就行了。 这题主要是注意下细节，调试可能比较烦，算法很简单，耐心做就OK了。 具体算法详见代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;using namespace std;string a, b;int len;int cntl[10], cntr[10];bool found;int last;int ans[65];bool dfs1(int s, int depth)&#123; if (depth == len) return false; int start = 0; bool fail = true; int now = a[depth] - '0'; if (s) start = now; for (int i = start; i &lt;= 9; i++) if (cntl[i]) &#123; cntl[i]--, ans[depth] = i; if(i == start &amp;&amp; s) s = 1; else s = 0; fail = dfs1(s, depth + 1); if (fail) cntl[i]++; else&#123;fail = false; break;&#125; &#125; return fail;&#125;bool dfs2(int s, int depth)&#123; if (depth == len) return false; int start = 9; bool fail = true; int now = a[depth] - '0'; if (s) &#123; start = now; if (depth == len - 1) start--; &#125; for (int i = start; i &gt;= 0 + (!depth); i--) if (cntr[i]) &#123; cntr[i]--, ans[depth] = i; if(i == start &amp;&amp; s) s = 1; else s = 0; fail = dfs2(s, depth + 1); if (fail) cntr[i]++; else&#123;fail = false; break;&#125; &#125; return fail;&#125;int main()&#123; cin &gt;&gt; a &gt;&gt; b; len = a.length(); for (int i = 0; i &lt; len; i++) cntl[b[i] - '0']++, cntr[b[i] - '0']++; if (dfs1(1, 0)) cout &lt;&lt; "0"; else for (int i = 0; i &lt; len; i++) cout &lt;&lt; ans[i]; cout &lt;&lt; endl; if (dfs2(1, 0)) cout &lt;&lt; "0"; else for (int i = 0; i &lt; len; i++) cout &lt;&lt; ans[i]; cout &lt;&lt; endl; return 0;&#125; Data评测请至洛谷SP3889。]]></content>
      <categories>
        <category>solution</category>
      </categories>
      <tags>
        <tag>搜索</tag>
        <tag>Balkan</tag>
        <tag>2008</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[友链]]></title>
    <url>%2Ffriends%2F</url>
    <content type="text"><![CDATA[%%%orz以下所有吊打我的大佬：memset0 redbag M-sea rqy lxy 请在评论区回复以交换友链]]></content>
      <categories>
        <category>Intro</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[类别索引]]></title>
    <url>%2Fcategory%2F</url>
    <content type="text"><![CDATA[介绍题解]]></content>
      <categories>
        <category>system</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[标签索引]]></title>
    <url>%2Ftag%2F</url>
    <content type="text"><![CDATA[题库、比赛、地区标签Balkan BOI CEOI 年份标签1995 2008 2009 2013 算法标签BFS DFS 反色 滚动数组 搜索 悬线法]]></content>
      <categories>
        <category>system</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[BOI2013 tracks in the snow 题解]]></title>
    <url>%2FBOI2013-tracks-in-the-snow%2F</url>
    <content type="text"><![CDATA[ProblemDescribeThere is a rectangular meadow in a forest, having been covered with a blanket of fresh snow in themorning (left in the figure below). Rabbits and foxes, who live in the forest, are crossing the meadow and leave their tracks in the snow. They always enter in the upper left corner and leave the meadow from the lower right corner. In between they can move back and forth, playing in the snow, even crossing their own tracks. At anytime there is at most one animal on the meadow. No animal enters the meadow more than once. The movements of the animals can be described by dividing the meadow into quadratic cells. The animals never move diagonally in a single step and they never jump over a cell. When an animal enters a cell its tracks will cover all previous tracks left in this cell.For example, first a rabbit crossed the meadow from top-left to bottom-right (middle in the figure).After that, a fox crossed, and now his tracks are partially covering the rabbit’s (right in the figure). 12345........ RRR..... FFR............. ..RRR... .FRRR........... ..R..... .FFFFF.......... ..RRRR.R ..RRRFFR........ .....RRR .....FFF You are given a map of the meadow at some time after indicating for each cell if there are any visible tracks and whether they were left by a rabbit or by a fox (right in the figure). You are interested in the local wildlife population. Write a program to determine the minimal possible number N of animals that must have crossed the meadow to leave the given pattern of tracks in the snow. InputThe first line contains two integers H and W, the height and the width of the map of the meadow. H lines follow with exactly W characters on each: the map, where ‘.’ marks untouched snow, ‘R’ a spot where a rabbit’s track is the topmost one, and ‘F’ a spot where a fox’s track is the topmost one. There is at least one track on the meadow. OutputThe output should consist of a single integer: the minimal number N ≥ 1 of animals that could have left the tracks given in the input. Constraints1 ≤ H, W ≤ 4000In test cases worth 30 points: N ≤ 200 and H, W ≤ 500 Example1234567Input #15 8 FFR......FRRR....FFFFF....RRRFFR.....FFF 12Output #12 LimitsTime limit: 2 sec per test case Memory limit: 1300 MB per test case Solution注意到测试数据保证有解。 主要题干已经加粗。 暴力标签里的BFS已经明示了这是一道搜索题。 题目里很重要的一条信息是脚印可以覆盖。 于是可以想到，如果两只动物交替走，那么后一次动物走过的地方即使上一次动物可以走的地方。 我们可以将走过的动物脚印全部都变为另外一种动物的脚印，这样下来，如果全屏只有一只动物的脚印，那么就说明不需要再有别的动物走了。 因为每一次反色都代表了一只动物走过，所以答案就是 运行次数+1。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//TLE code#include &lt;bits/stdc++.h&gt;using namespace std;const int dx[4] = &#123; -1, 0, 1, 0 &#125;;const int dy[4] = &#123; 0, 1, 0, -1 &#125;;const int MAXN = 4000 + 5;char ch;int n, m;int g[MAXN][MAXN];bool Visit[MAXN][MAXN];queue&lt;pair&lt;int, int&gt; &gt; Q;int ans;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; ch = getchar(); for (int j = 1; j &lt;= m; j++) &#123; ch = getchar(); switch (ch) &#123; case 'R': g[i][j] = 0; break; case '.': g[i][j] = -1; break; case 'F': g[i][j] = 1; break; &#125; &#125; &#125; while (true) &#123; for (int i = 0; i &lt;= n + 1; i++) for (int j = 0; j &lt;= m + 1; j++) Visit[i][j] = false; ans++; Q.push(make_pair(1, 1)); while (!Q.empty()) &#123; pair&lt;int, int&gt; now = Q.front(); Q.pop(); int x = now.first, y = now.second; Visit[x][y] = true; for (int i = 0; i &lt; 4; i++) &#123; int fx = x + dx[i], fy = y + dy[i]; if (fx &lt; 1 || fy &lt; 1 || fx &gt; n || fy &gt; m || g[x][y] != g[fx][fy] || Visit[fx][fy]) continue; Q.push(make_pair(fx, fy)); &#125; &#125; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) if (Visit[i][j]) g[i][j] = 1 - g[i][j]; bool ra = false, fo = false; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) &#123; if (g[i][j] == 0) ra = true; else if (g[i][j] == 1) fo = true; &#125; if (!(ra &amp;&amp; fo)) break; &#125; cout &lt;&lt; ans + 1 &lt;&lt; endl; return 0;&#125; 交上去一看，T飞了，第二个点就跑了9s。 因此我们需要对这个算法进行一点优化 优化之所以会TLE，对于循环退出的判断占了很大一部分。并且，我们在搜索过程中，反复经过已经走过的位置，这样效率便很低。 因为走过的部分一定可以再走，所以我们只需要考虑没走过的部分。 优化后的算法变成了“填棋盘”，即整个棋盘只走一遍，大大提高了效率。 对于循环退出的判断也优化了很多，详见代码。 （注：这份代码在本机上测最慢的点跑了将近4s，如果还有优化请在评论区回复，感谢您的贡献） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;using namespace std;const int dx[4] = &#123; -1, 0, 1, 0 &#125;;const int dy[4] = &#123; 0, 1, 0, -1 &#125;;const int MAXN = 4000 + 5;char ch;int n, m;bool g[MAXN][MAXN];bool Visit[MAXN][MAXN];queue&lt;pair&lt;int, int&gt; &gt; Q[2];int ans;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; ch = getchar(); for (int j = 1; j &lt;= m; j++) &#123; ch = getchar(); switch (ch) &#123; case 'R': g[i][j] = 0; break; case '.': Visit[i][j] = true; break; case 'F': g[i][j] = 1; break; &#125; &#125; &#125; Q[0].push(make_pair(1, 1)); Q[0].push(make_pair(n, m)); int k = 0; while (!Q[k].empty()) &#123; while (!Q[k].empty()) &#123; pair&lt;int, int&gt; now = Q[k].front(); Q[k].pop(); int x = now.first, y = now.second; if (Visit[x][y]) continue; Visit[x][y] = true; for (int i = 0; i &lt; 4; i++) &#123; int fx = x + dx[i], fy = y + dy[i]; if (fx &lt; 1 || fy &lt; 1 || fx &gt; n || fy &gt; m || Visit[fx][fy]) continue; if (g[x][y] ^ g[fx][fy]) Q[1 - k].push(make_pair(fx, fy)); else Q[k].push(make_pair(fx, fy)); &#125; &#125; k = 1 - k; ans++; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; Data测试数据 提取码：3vm2]]></content>
      <categories>
        <category>solution</category>
      </categories>
      <tags>
        <tag>BOI</tag>
        <tag>2013</tag>
        <tag>BFS</tag>
        <tag>反色</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于]]></title>
    <url>%2Fabout%2F</url>
    <content type="text"><![CDATA[这里是蒟蒻fanhy的博客。 本人是G2017 SH OIer, 六年级开始跳OI这个坑，现在已经爬不出来了QAQ 微小的成就： year prize 2018 NOIPpj一等奖 欢迎大佬前来虐菜。 我的洛咕账号 以下全部ORZ%%%： 大佬同学 同校神犇 无敌巨佬]]></content>
      <categories>
        <category>Intro</category>
      </categories>
  </entry>
</search>
