<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Balkan2008 closest 题解]]></title>
    <url>%2FBalkan2008-closest%2F</url>
    <content type="text"><![CDATA[Problem问题描述：有两个没有前导$0$的$n$位十进制数$A$和$B$。我们需要找到两个最接近$A$的$n$位数(第1个大于等于$A$，第二小于$A$)，包含B的所有数字。 例如，如果$A=3022$，$B=1232$，采用$B$的数字，我们可以得到以下$4$位数:$1223$，$1232$，$1322$，$2123$，$2132$，$2213$，$2231$，$2312$，$2321$，$3122$，$3212$和$3221$。 最小的大于等于$A$是$3122$，最大小于$A$的是$2321$。 如果$A=1232$，而$B=3022$，可能的$4$位数是$2023$，$2032$，$2203$，$2230$，$2302$，$2320$，$3022$，$3202$和3220$。 最小的大于等于$A$是$3122$，最大小于$A$的是$2023$。不存在小于$4$的数。 编写程序，对于给定的$A$和$B$，找出最接近$A$的包含$B$的所有数字的数，或者确定其中一个是不存在的。 输入格式：输入两行，都是没有前导$0$的$n(1≤n≤60)$位正整数，第一行是$A$，第二行是$B$。 输出格式：输出两行，每行一个十进制数。 第1行是最小的大于等于$A$的没有前导$0$的，包含$B$所有数字的$n$位十进制数。如果这样的数不存在，则输出$0$。 第2行是最大的小于$A$的没有前导$0$的，包含$B$所有数字的$n$位十进制数。如果这样的数不存在，则输出$0$。 样例输入输出：12345Input30756604 12345Output40660 12345Input30002034562454 12345Output42445562655444 Solution洛谷SP3889与本题基本一样。 本题难度较低。 很容易想到，既然越接近越好，那么就一位一位匹配，能匹配上就用，如果发现完成不了回溯就行了。 这题主要是注意下细节，调试可能比较烦，算法很简单，耐心做就OK了。 具体算法详见代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;using namespace std;string a, b;int len;int cntl[10], cntr[10];bool found;int last;int ans[65];bool dfs1(int s, int depth)&#123; if (depth == len) return false; int start = 0; bool fail = true; int now = a[depth] - '0'; if (s) start = now; for (int i = start; i &lt;= 9; i++) if (cntl[i]) &#123; cntl[i]--, ans[depth] = i; if(i == start &amp;&amp; s) s = 1; else s = 0; fail = dfs1(s, depth + 1); if (fail) cntl[i]++; else&#123;fail = false; break;&#125; &#125; return fail;&#125;bool dfs2(int s, int depth)&#123; if (depth == len) return false; int start = 9; bool fail = true; int now = a[depth] - '0'; if (s) &#123; start = now; if (depth == len - 1) start--; &#125; for (int i = start; i &gt;= 0 + (!depth); i--) if (cntr[i]) &#123; cntr[i]--, ans[depth] = i; if(i == start &amp;&amp; s) s = 1; else s = 0; fail = dfs2(s, depth + 1); if (fail) cntr[i]++; else&#123;fail = false; break;&#125; &#125; return fail;&#125;int main()&#123; cin &gt;&gt; a &gt;&gt; b; len = a.length(); for (int i = 0; i &lt; len; i++) cntl[b[i] - '0']++, cntr[b[i] - '0']++; if (dfs1(1, 0)) cout &lt;&lt; "0"; else for (int i = 0; i &lt; len; i++) cout &lt;&lt; ans[i]; cout &lt;&lt; endl; if (dfs2(1, 0)) cout &lt;&lt; "0"; else for (int i = 0; i &lt; len; i++) cout &lt;&lt; ans[i]; cout &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>solution</category>
      </categories>
      <tags>
        <tag>Balkan</tag>
        <tag>2008</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[友链]]></title>
    <url>%2Ffriends%2F</url>
    <content type="text"><![CDATA[%%%orz以下所有吊打我的大佬：memset0 redbag M-sea rqy lxy 请在评论区回复以交换友链]]></content>
      <categories>
        <category>Intro</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[类别索引]]></title>
    <url>%2Fcategory%2F</url>
    <content type="text"><![CDATA[介绍题解]]></content>
      <categories>
        <category>system</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[标签索引]]></title>
    <url>%2Ftag%2F</url>
    <content type="text"><![CDATA[题库、比赛、地区标签Balkan BOI 年份标签2008 2013 算法标签BFS DFS 反色]]></content>
      <categories>
        <category>system</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[BOI2013 tracks in the snow 题解]]></title>
    <url>%2FBOI2013-tracks-in-the-snow%2F</url>
    <content type="text"><![CDATA[ProblemDescribeThere is a rectangular meadow in a forest, having been covered with a blanket of fresh snow in themorning (left in the figure below). Rabbits and foxes, who live in the forest, are crossing the meadow and leave their tracks in the snow. They always enter in the upper left corner and leave the meadow from the lower right corner. In between they can move back and forth, playing in the snow, even crossing their own tracks. At anytime there is at most one animal on the meadow. No animal enters the meadow more than once. The movements of the animals can be described by dividing the meadow into quadratic cells. The animals never move diagonally in a single step and they never jump over a cell. When an animal enters a cell its tracks will cover all previous tracks left in this cell.For example, first a rabbit crossed the meadow from top-left to bottom-right (middle in the figure).After that, a fox crossed, and now his tracks are partially covering the rabbit’s (right in the figure). 12345........ RRR..... FFR............. ..RRR... .FRRR........... ..R..... .FFFFF.......... ..RRRR.R ..RRRFFR........ .....RRR .....FFF You are given a map of the meadow at some time after indicating for each cell if there are any visible tracks and whether they were left by a rabbit or by a fox (right in the figure). You are interested in the local wildlife population. Write a program to determine the minimal possible number N of animals that must have crossed the meadow to leave the given pattern of tracks in the snow. InputThe first line contains two integers H and W, the height and the width of the map of the meadow. H lines follow with exactly W characters on each: the map, where ‘.’ marks untouched snow, ‘R’ a spot where a rabbit’s track is the topmost one, and ‘F’ a spot where a fox’s track is the topmost one. There is at least one track on the meadow. OutputThe output should consist of a single integer: the minimal number N ≥ 1 of animals that could have left the tracks given in the input. Constraints1 ≤ H, W ≤ 4000In test cases worth 30 points: N ≤ 200 and H, W ≤ 500 Example1234567Input 5 8 FFR......FRRR....FFFFF....RRRFFR.....FFF 12Output2 LimitsTime limit: 2 sec per test case Memory limit: 1300 MB per test case Solution注意到测试数据保证有解。 主要题干已经加粗。 暴力标签里的BFS已经明示了这是一道搜索题。 题目里很重要的一条信息是脚印可以覆盖。 于是可以想到，如果两只动物交替走，那么后一次动物走过的地方即使上一次动物可以走的地方。 我们可以将走过的动物脚印全部都变为另外一种动物的脚印，这样下来，如果全屏只有一只动物的脚印，那么就说明不需要再有别的动物走了。 因为每一次反色都代表了一只动物走过，所以答案就是 运行次数+1。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//TLE code#include &lt;bits/stdc++.h&gt;using namespace std;const int dx[4] = &#123; -1, 0, 1, 0 &#125;;const int dy[4] = &#123; 0, 1, 0, -1 &#125;;const int MAXN = 4000 + 5;char ch;int n, m;int g[MAXN][MAXN];bool Visit[MAXN][MAXN];queue&lt;pair&lt;int, int&gt; &gt; Q;int ans;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; ch = getchar(); for (int j = 1; j &lt;= m; j++) &#123; ch = getchar(); switch (ch) &#123; case 'R': g[i][j] = 0; break; case '.': g[i][j] = -1; break; case 'F': g[i][j] = 1; break; &#125; &#125; &#125; while (true) &#123; for (int i = 0; i &lt;= n + 1; i++) for (int j = 0; j &lt;= m + 1; j++) Visit[i][j] = false; ans++; Q.push(make_pair(1, 1)); while (!Q.empty()) &#123; pair&lt;int, int&gt; now = Q.front(); Q.pop(); int x = now.first, y = now.second; Visit[x][y] = true; for (int i = 0; i &lt; 4; i++) &#123; int fx = x + dx[i], fy = y + dy[i]; if (fx &lt; 1 || fy &lt; 1 || fx &gt; n || fy &gt; m || g[x][y] != g[fx][fy] || Visit[fx][fy]) continue; Q.push(make_pair(fx, fy)); &#125; &#125; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) if (Visit[i][j]) g[i][j] = 1 - g[i][j]; bool ra = false, fo = false; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) &#123; if (g[i][j] == 0) ra = true; else if (g[i][j] == 1) fo = true; &#125; if (!(ra &amp;&amp; fo)) break; &#125; cout &lt;&lt; ans + 1 &lt;&lt; endl; return 0;&#125; 交上去一看，T飞了，第二个点就跑了9s。 因此我们需要对这个算法进行一点优化 优化之所以会TLE，对于循环退出的判断占了很大一部分。并且，我们在搜索过程中，反复经过已经走过的位置，这样效率便很低。 因为走过的部分一定可以再走，所以我们只需要考虑没走过的部分。 优化后的算法变成了“填棋盘”，即整个棋盘只走一遍，大大提高了效率。 对于循环退出的判断也优化了很多，详见代码。 （注：这份代码在本机上测最慢的点跑了将近4s，如果还有优化请在评论区回复） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;using namespace std;const int dx[4] = &#123; -1, 0, 1, 0 &#125;;const int dy[4] = &#123; 0, 1, 0, -1 &#125;;const int MAXN = 4000 + 5;char ch;int n, m;bool g[MAXN][MAXN];bool Visit[MAXN][MAXN];queue&lt;pair&lt;int, int&gt; &gt; Q[2];int ans;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; ch = getchar(); for (int j = 1; j &lt;= m; j++) &#123; ch = getchar(); switch (ch) &#123; case 'R': g[i][j] = 0; break; case '.': Visit[i][j] = true; break; case 'F': g[i][j] = 1; break; &#125; &#125; &#125; Q[0].push(make_pair(1, 1)); Q[0].push(make_pair(n, m)); int k = 0; while (!Q[k].empty()) &#123; while (!Q[k].empty()) &#123; pair&lt;int, int&gt; now = Q[k].front(); Q[k].pop(); int x = now.first, y = now.second; if (Visit[x][y]) continue; Visit[x][y] = true; for (int i = 0; i &lt; 4; i++) &#123; int fx = x + dx[i], fy = y + dy[i]; if (fx &lt; 1 || fy &lt; 1 || fx &gt; n || fy &gt; m || Visit[fx][fy]) continue; if (g[x][y] ^ g[fx][fy]) Q[1 - k].push(make_pair(fx, fy)); else Q[k].push(make_pair(fx, fy)); &#125; &#125; k = 1 - k; ans++; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 是不是又短又快呢？ 最后附上测试数据 提取码：3vm2]]></content>
      <categories>
        <category>solution</category>
      </categories>
      <tags>
        <tag>BOI</tag>
        <tag>2013</tag>
        <tag>BFS</tag>
        <tag>反色</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于]]></title>
    <url>%2Fabout%2F</url>
    <content type="text"><![CDATA[这里是蒟蒻fanhy的博客。 本人是G2017 SH OIer, 六年级开始跳OI这个坑，现在已经爬不出来了QAQ 微小的成就： year prize 2018 NOIPpj一等奖 欢迎大佬前来虐菜。 我的洛咕账号 以下全部ORZ%%%： 大佬同学 同校神犇 无敌巨佬]]></content>
      <categories>
        <category>Intro</category>
      </categories>
  </entry>
</search>
