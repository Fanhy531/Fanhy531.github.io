<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[「置顶」fanhy的程序指南]]></title>
    <url>%2Fprogram-guide%2F</url>
    <content type="text"><![CDATA[这里总结了fanhy大部分的写程序的经验，供各位参考，也欢迎在评论区指出错误或不足。 Warning 千万不要起重复的函数名，即使编译器成功编译了。 千万不要把很多代码压成1行。 千万不要跳着写代码，如果需要请在注释里写下TODO。 千万不要依赖编译器的调试功能，调试时先重新阅读一遍代码。 尽量不要起很短的变量名或函数名，自己要一眼能看懂。 尽量不要把一个变量作两个用途，否则调试会很困难。 边界一定写完整。 递归时一定不能出现不return的情况。 整篇代码统一设置从0或1开始，避免调试时不必要的麻烦。 getchar()注意吃换行。 使用sort排序结构体时最好在结构体中重载&gt;或&lt;。 易出错的函数：min(),max(),abs(),get(),gets(),memset().使用这些函数应当注意。 Reference1234567891011121314151617181920212223//快读、快写模板namespace IO &#123; char buf[110];&#125;template &lt;typename T&gt;inline void qr(T &amp;x) &#123; char ch=getchar(),lst=' '; while((ch &gt; '9') || (ch &lt; '0')) lst=ch,ch=getchar(); while((ch &gt;= '0') &amp;&amp; (ch &lt;= '9')) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); if(lst == '-') x=-x;&#125;template &lt;typename T&gt;inline void write(T x,const char aft,const bool pt) &#123; if(x &lt; 0) &#123;putchar('-');x=-x;&#125; rg int top=0; do &#123; IO::buf[++top]=x%10+'0';x/=10; &#125; while(x); while(top) putchar(IO::buf[top--]); if(pt) putchar(aft);&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[BOI2010 grid 题解]]></title>
    <url>%2FBOI2010-grid%2F</url>
    <content type="text"><![CDATA[Problem题目描述考虑下面的字母网格: 从字母网格读取的单词TARTU有7种方式: 给出字母网格中的一个单词，请你计算从字母网格的读取这个单词的方式个数。单词的第一个字母，可以从字母网格的任意单元格开始，下一个字母可从相邻单元(水平,垂直或对角线)读取。读单词时，一个单元格字母可多次读取。 输入格式：第一行包含三个整数：$H(H≤200)$网格的高度，$W(W≤200)$网格的宽度，和$L(L≤100)$单词的最大长度。 下面的$H$行，每行$W$个字母描述网格。最后一行是长度为$L$单词。网格和单词都是大写的英文字母(A~Z)。 输出格式：仅输出一个整数，你可以假设方案个数不超过${10}^{18}$。 样例输入输出：123456Input #13 4 5ERATATSRAUTUTARTU 12Output #17 12345Input #22 2 10AAAAAAAAAAAAAA 12Output #278732 Solution搜索首先想到的自然是搜索。 于是最劣运算次数约为：$200×8^{99}≈5.1×10^{91}‬$ 暴搜挂着机，打表出省一 对于深搜最常用的两种优化：剪枝、记忆化。 好像这道题不能剪枝？那就用记忆化。 $f[x][y][depth]$记录当前坐标上的字母为第$depth$位时之后有多少种可行方案。 迭代模拟由于当前一层的地图（即$f[][][depth]$）只受上一层地图（即$f[][][depth-1]$）的影响，因此可以考虑将递归转迭代。 $f[x][y][depth]$记录当前坐标上的字母为第$depth$位时有多少种可行方案。 可以发现$f[x][y][depth]$就是它周围$8$个方格里的$f[][][depth-1]$之和。 特殊情况： $letter[x][y]≠word[depth]$，则$f[x][y][depth]=0$; $depth=1且letter[x][y]=word[depth]$，则$f[x][y][depth]=1$。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;const int dx[8] = &#123; 1, 1, 0, -1, -1, -1, 0, 1 &#125;;const int dy[8] = &#123; 0, 1, 1, 1, 0, -1, -1, -1 &#125;;const int MAXN = 200 + 5;const int MAXLEN = 100 + 5;int n, m, len;char _map[MAXN][MAXN], word[MAXLEN];long long f[MAXLEN][MAXN][MAXN];long long ans;int main()&#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; len; for (int i = 1; i &lt;= n; i++) &#123; _map[i][0] = getchar(); for (int j = 1; j &lt;= m; j++) _map[i][j] = getchar(); &#125; word[0] = getchar(); for (int i = 1; i &lt;= len; i++) word[i] = getchar(); for (int i = 1; i &lt;= len; i++) for (int j = 1; j &lt;= n; j++) for (int k = 1; k &lt;= m; k++) &#123; if (_map[j][k] != word[i]) &#123; f[i][j][k] = 0; continue; &#125; if (i == 1) &#123; f[i][j][k] = 1; continue; &#125; for (int diri = 0; diri &lt; 8; diri++) f[i][j][k] += f[i - 1][j + dx[diri]][k + dy[diri]]; &#125; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) ans += f[len][i][j]; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 当然写成滚动数组更好，但是本人太懒，外加数据范围不大，为了增加代码可读性，没有展示滚动数组的代码。 Data链接：https://pan.baidu.com/s/1UUtmZlnT5NjhE_8nDr-Euw 提取码：grwc 数据仓库：https://github.com/Fanhy531/testdata]]></content>
      <categories>
        <category>solution</category>
      </categories>
      <tags>
        <tag>BOI</tag>
        <tag>2010</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P3381 最小费用最大流 题解]]></title>
    <url>%2FLuogu-P3381%2F</url>
    <content type="text"><![CDATA[Problem题目描述如题，给出一个网络图，以及其源点和汇点，每条边已知其最大流量和单位流量费用，求出其网络最大流和在最大流情况下的最小费用。 输入输出格式输入格式：第一行包含四个正整数$N,M,S,T$，分别表示点的个数、有向边的个数、源点序号、汇点序号。 接下来M行每行包含四个正整数$u_i,v_i,w_i,f_i$，表示第i条有向边从$u_i$出发，到达$v_i$，边权为$w_i$（即该边最大流量为$w_i$），单位流量的费用为$f_i$。 输出格式：一行，包含两个整数，依次为最大流量和在最大流量情况下的最小费用。 输入输出样例1234567Input #14 5 4 34 2 30 24 3 20 32 3 20 12 1 30 91 3 40 5 12Output #150 280 说明时空限制：1000ms,128MB 最后两个点1200ms 数据规模： 对于30%的数据：$N&lt;=10,M&lt;=10$ 对于70%的数据：$N&lt;=1000,M&lt;=1000$ 对于100%的数据：$N&lt;=5000,M&lt;=50000$ 样例说明： 如图，最优方案如下： 第一条流为4–&gt;3，流量为$20$，费用为$3×20=60$。 第二条流为4–&gt;2–&gt;3，流量为$20$，费用为$(2+1)×20=60$。 第三条流为4–&gt;2–&gt;1–&gt;3，流量为$10$，费用为$(2+9+5)×10=160$。 故最大流量为$50$，在此状况下最小费用为$60+60+160=280$。 故输出$50 280$。 Solution网络流模板题。 要求在满足最大流情况下的最小费用，可以在最大流的代码上做一些修改。 原本的EK算法是每次BFS只找流量最大的路径路径，现在要求最小费用，可以先找费用最小的，而不是流量最大的。毕竟有路肯定先挑费用少的走嘛。在EK上套一个SPFA就可以了。 如何证明该算法的正确性？ 首先要知道，每条流的顺序对最大流的数值不产生影响。那么，先找费用最小的流，可以保证在满足最大流的情况下，找到最小的费用。并且，也不用担心某条流会因为费用太大跑不进去（除非有其他费用更小的流满足了最大流），费用再大也没有∞大，肯定是可以的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;#define INF INT_MAXusing namespace std;const int MAXN = 5000 + 5;const int MAXM = 100000 + 5;struct node &#123; int from, to, next, cost, pay; &#125;edge[MAXM];int head[MAXN], cnt = 1;int n, m, start, End;int s, t, v, c;int inc, ans, mincost;int last[MAXN], flow[MAXN], dis[MAXN];bool Visit[MAXN];queue&lt;int&gt; q;void add(int a, int b, int v, int p)&#123; edge[++cnt].cost = v; edge[cnt].pay = p; edge[cnt].from = a; edge[cnt].to = b; edge[cnt].next = head[a], head[a] = cnt;&#125;int bfs()&#123; for (int i = 0; i &lt; MAXN; i++) dis[i] = INF; memset(Visit, false, sizeof Visit); memset(last, 0, sizeof last); q.push(start); flow[start] = INF; dis[start] = 0; Visit[start] = true; while (!q.empty()) &#123; int now = q.front(); q.pop(); Visit[now] = false; for (int i = head[now]; i; i = edge[i].next) &#123; int f = edge[i].to; if (edge[i].cost &amp;&amp; dis[f] &gt; dis[now] + edge[i].pay) //首先需要有流量才能访问，之后满足费用较小 &#123; flow[f] = min(flow[now], edge[i].cost); last[f] = i, dis[f] = dis[now] + edge[i].pay; if (!Visit[f]) Visit[f] = true, q.push(f); //SPFA找最小费用 &#125; &#125; &#125; if (!last[End]) return 0; return flow[End];&#125;void upd(int k)&#123; int now = End; while (now != start) &#123; int p = last[now]; edge[p].cost -= k; edge[p ^ 1].cost += k; now = edge[p].from; &#125; mincost += dis[End] * k;&#125;void maxflow() &#123; while (inc = bfs()) upd(inc), ans += inc; &#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; start &gt;&gt; End; for (int i = 1; i &lt;= m; i++) &#123; cin &gt;&gt; s &gt;&gt; t &gt;&gt; v &gt;&gt; c; add(s, t, v, c); add(t, s, 0, -c); //反向边是反悔用的，反向互逆的两条流流量抵消，费用抵消 &#125; maxflow(); cout &lt;&lt; ans &lt;&lt; ' ' &lt;&lt; mincost &lt;&lt; endl; return 0;&#125; 可能开始会有点懵，配上图仔细想一会就能理解。 Data评测请至洛谷P3381。 LOJ参考数据这里找 注意：LOJ题目和本题略有不同。]]></content>
      <categories>
        <category>solution</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>模板题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOI2009 raisins 题解]]></title>
    <url>%2FIOI2009-raisins%2F</url>
    <content type="text"><![CDATA[Problem问题描述：普罗夫迪夫的著名巧克力大师Bonny需要切开一板带有葡萄干的巧克力。巧克力是一个包含许多相同的方形小块的矩形。小块沿着巧克力的边排列成$n$行$m$列，即共有$n×m$块。每个小块上有$1$个或多个葡萄干，没有葡萄干在小块的边上或者跨过两个小块。 最开始，巧克力是一整块。Bonny需要把它切成上述的$n×m$个独立的小块。因为Bonny很忙，她需要她的助手Sly Peter帮她切。Peter只能从一端到另一端切直线并且他要为他的每一刀得到报酬。Bonny手头没有钱，但是她有足够的葡萄干，所以她提出用葡萄干付给Peter。Sly Peter同意接受葡萄干，但是有下面的条件：每次他把给定的一块巧克力切成两小块，他都要得到和那块给定的巧克力上葡萄干数目相同的葡萄干。 Bonny想要付给Peter尽可能少的葡萄干。她知道这$n×m$个小块中每一个小块上葡萄干的数目。她可以选择递给Peter的巧克力的顺序，也可以告诉Peter如何切(横切还是竖切)以及从哪里切。请告诉Bonny如何把巧克力切成一个个独立的小块。使她能够付给Sly Peter尽可能少的葡萄干。 任务写一个程序，给定每个小块上葡萄干的数目，计算Bonny要付给Sly Peter的最少的葡萄干的数目。 数据规模$1≤n,m≤50$ 巧克力两条边上小块的数目 $1≤R_{k,p}≤1,000$ 第$k$行第$p$列的小块上的葡萄干数目 有25分的评测数据，$n,m≤7$。 输入你的程序必须从标准输入中读取下列数据： 第一行包含整数$n$和$m$，以一个空格隔开。 接下来的n行描述了每个小块上葡萄干的数目。这n行中第$k$行描述的是第$k$行小块巧克力。每行包含$m$个整数，分别以一个空格隔开。这些整数描述的是该行从左到右的小块。第$k$行的第$p$个整数表示位于第$k$行第$p$列的小块上的葡萄干数目。 输出你的程序必须向标准输出写入一行，该行包含一个整数Bonny：要付给Sly Peter的最少的葡萄干的数目。 样例1234Input #12 32 7 51 9 5 12Output #177 一种可能的花费$77$的切法(许多种之一)： 第一刀，将第$3$列切下，Bonny要付给Peter$29$个葡萄干。 接下来，Bonny将小的一块给Peter：两小块各有$5$个葡萄干的那块，Peter把它从中切开得到$10$个葡萄干。 接下来，Bonny给Peter第一刀后较大的一块：有$2,7,1$和$9$个葡萄干的那块，Bonny要求Peter横切，即将第一和第二行分开，得到$19$个葡萄干。 接下来，Bonny要求Peter切开左上部的一块，付$9$个葡萄干。最后，Bonny要求Peter切开左下部的一块，付$10$个葡萄干。 Bonny的总花费是$29+10+19+9+10=77$个葡萄干。没有其他的切法能够花费更少的葡萄干而把该巧克力切成$6$小块。 Solution二分错解我最先的睿智想法：既然越少越好，那么 ——–以下是扯淡内容，读者请不要相信——– 左右两边越平均越好（不知道哪里来的稀奇想法） ——–以下不是扯淡内容——– 对于这种题，显然做一个前缀和。 又因为$1≤n,m≤50$，则可以做$4$维前缀和，把每一个可能割出来的巧克力块上的葡萄干数全部记录下来（有的是空间）。 接下来进行分治，根据我的稀奇想法，二分前缀和找到平衡线使割开的两部分上的葡萄干数尽量接近。 接下来就是递归啊递归啊递归啊递归… 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 50 + 5;int n, m;long long raisin[MAXN][MAXN];long long sum[MAXN][MAXN], cnt[MAXN][MAXN][MAXN][MAXN];long long ans;long long area(int ldx, int ldy, int urx, int ury)&#123; return sum[urx][ury] - sum[ldx - 1][ury] - sum[urx][ldy - 1] + sum[ldx - 1][ldy - 1];&#125;long long dfs(int ldx, int ldy, int urx, int ury, bool k) //k表示横向切还是纵向切&#123; int l, r; long long ans1 = LONG_LONG_MAX, ans2 = LONG_LONG_MAX; double half = cnt[ldx][ldy][urx][ury] / 2.0; //当前处理的巧克力上葡萄干总数的一半，不用double也行 if (k) &#123; //二分思想：左右两边最接近，即左边和总数一半接近，二分刀切在哪里 l = ldx, r = urx; while (l + 1 &lt; r) &#123; int mid = (l + r) / 2; if (cnt[ldx][ldy][mid][ury] &gt; half) r = mid; else l = mid; &#125; //选l和r中离总数一半最接近的切 int flag = (fabs(half - cnt[ldx][ldy][l][ury]) &lt; fabs(cnt[ldx][ldy][r][ury] - half) ? l : r); if (flag == ldx &amp;&amp; ldy == ury) ans1 = cnt[ldx][ldy][ldx][ldy]; //切下来边长为1 else &#123; if (flag != ldx) ans1 = dfs(ldx, ldy, flag, ury, 1); //长&gt;1，可以切 if (ldy != ury) ans1 = min(ans1, dfs(ldx, ldy, flag, ury, 0)); //宽&gt;1，可以切 &#125; if (flag + 1 == urx &amp;&amp; ldy == ury) ans2 = cnt[urx][ury][urx][ury]; else &#123; if (flag + 1 != urx) ans2 = dfs(flag + 1, ldy, urx, ury, 1); if (ldy != ury) ans2 = min(ans2, dfs(flag + 1, ldy, urx, ury, 0)); &#125; return ans1 + ans2 + cnt[ldx][ldy][urx][ury]; &#125; else &#123; l = ldy, r = ury; while (l + 1 &lt; r) &#123; int mid = (l + r) / 2; if (cnt[ldx][ldy][urx][mid] &gt; half) r = mid; else l = mid; &#125; int flag = (fabs(half - cnt[ldx][ldy][urx][l]) &lt; fabs(cnt[ldx][ldy][urx][r] - half) ? l : r); if (flag == ldy &amp;&amp; ldx == urx) ans1 = cnt[ldx][ldy][ldx][ldy]; else &#123; if (flag != ldy) ans1 = dfs(ldx, ldy, urx, flag, 0); if (ldx != urx) ans1 = min(ans1, dfs(ldx, ldy, urx, flag, 1)); &#125; if (flag + 1 == ury &amp;&amp; ldx == urx) ans2 = cnt[urx][ury][urx][ury]; else &#123; if (flag + 1 != ury) ans2 = dfs(ldx, flag + 1, urx, ury, 0); if (ldx != urx) ans2 = min(ans2, dfs(ldx, flag + 1, urx, ury, 1)); &#125; return ans1 + ans2 + cnt[ldx][ldy][urx][ury]; &#125;&#125;int main()&#123; freopen("raisins.in", "r", stdin); freopen("raisins.sol", "w", stdout); cin &gt;&gt; n &gt;&gt; m; if (n == 1 &amp;&amp; m == 1) &#123; cin &gt;&gt; raisin[1][1]; cout &lt;&lt; 0 &lt;&lt; endl; return 0; &#125; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) cin &gt;&gt; raisin[i][j]; for (int i = 1; i &lt;= m; i++) for (int j = 1; j &lt;= n; j++) sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + raisin[n - j + 1][i]; for (int i = 1; i &lt;= m; i++) for (int j = 1; j &lt;= n; j++) for (int k = 1; k &lt;= i; k++) for (int l = 1; l &lt;= j; l++) cnt[k][l][i][j] = area(k, l, i, j); if (n != 1) ans = dfs(1, 1, m, n, 0); if (m != 1) ans = min(ans, dfs(1, 1, m, n, 1)); cout &lt;&lt; ans - cnt[1][1][m][n] &lt;&lt; endl; return 0;&#125; 完美地WA了。 找了两天bug没找出来，只好否认：自己的算法错了。 于是一时性起： 不用二分了，我倒要看看暴力能拿几分！ 正解正解就是暴力。 把上面一段代码的二分部分改成 1for (int flag = ldx; flag &lt; urx; flag++) 就能TLE。（手动滑稽 空间多到溢出的我又开始挥霍：记忆化每一个巧克力块的最小切割支出。 然而还是TLE了。 又想了半天优化，突然发现，之前是因为不能把边长为1的线段进行二分才加了那么多判断的，现在可是暴力啊，循环条件直接给舍了边长为1的情况了，于是愉快地把特判给省了。 然后就能发现，$k=true$或$k=false$是一样的情况，舍了。 就这么AC了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 50 + 5;int n, m;int raisin[MAXN][MAXN];int sum[MAXN][MAXN], cnt[MAXN][MAXN][MAXN][MAXN];int memory[MAXN][MAXN][MAXN][MAXN]; //记忆化int ans = INT_MAX;int dfs(int ldx, int ldy, int urx, int ury)&#123; if (memory[ldx][ldy][urx][ury]) return memory[ldx][ldy][urx][ury]; //记忆化 if (ldx == urx &amp;&amp; ldy == ury) return cnt[ldx][ldy][urx][ury]; //边长为1 int pay, tot = INT_MAX; for (int flag = ldx; flag &lt; urx; flag++) //横向切 &#123; pay = dfs(ldx, ldy, flag, ury) + dfs(flag + 1, ldy, urx, ury); if (tot &gt; pay) tot = pay; &#125; for (int flag = ldy; flag &lt; ury; flag++) //纵向切 &#123; pay = dfs(ldx, ldy, urx, flag) + dfs(ldx, flag + 1, urx, ury); if (tot &gt; pay) tot = pay; //pay取最小值 &#125; memory[ldx][ldy][urx][ury] = tot + cnt[ldx][ldy][urx][ury]; //返回：自己的花费+上一层自己一块所占的花费 return memory[ldx][ldy][urx][ury];&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; //边长为1不用切，输出0 if (n == 1 &amp;&amp; m == 1) &#123; cin &gt;&gt; raisin[1][1]; cout &lt;&lt; 0 &lt;&lt; endl; return 0; &#125; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) cin &gt;&gt; raisin[i][j]; for (int i = 1; i &lt;= m; i++) for (int j = 1; j &lt;= n; j++) sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + raisin[n - j + 1][i]; for (int i = 1; i &lt;= m; i++) for (int j = 1; j &lt;= n; j++) for (int k = 1; k &lt;= i; k++) for (int l = 1; l &lt;= j; l++) cnt[k][l][i][j] = sum[i][j] - sum[k - 1][j] - sum[i][l - 1] + sum[k - 1][l - 1]; //以上前缀和 ans = dfs(1, 1, m, n); cout &lt;&lt; ans - cnt[1][1][m][n] &lt;&lt; endl; //由于第一刀没有再上一层，减去总数 return 0;&#125; Data测试数据 提取码：0q3s]]></content>
      <categories>
        <category>solution</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>2009</tag>
        <tag>IOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写代码的小女孩]]></title>
    <url>%2FThe-Little-Program-Girl%2F</url>
    <content type="text"><![CDATA[天冷极了，下着雪，又快黑了。这是NOIP的前夜。在这又冷又黑的晚上，一个衣衫破烂的小女孩在机房敲着代码。她从班里逃出来的时候还拿着一本算导，但是有什么用呢？那是一本很破旧的书——那么大，一向是她妈妈垫桌角的。她默写SPFA的时候，年级主任突然冲进机房，吓得她把算导都丢掉了。书叫一个学数竞捡起来拿着跑了。他说，他可以用那本书当草纸，证明切比雪夫定理。 小女孩只好自己写二叉堆，一双小脚冻得红一块青一块的。她面前的草纸堆得满满的，上面全是DP转移方程。这一整天，没有一个OJ让她AC一道题，她已经交了32遍采药了。 可怜的小女孩！她又冷又饿，浑身战栗地写着二叉堆。CRT显示器发出的光落在她的枯黄的长头发上，那干枯的头发打成卷儿披在肩上，看上去就像二叉树，不过她没注意这些。每个显示器里都透出光来，机房里飘着一股CPU发糊的怪味，因为这是NOIP前夜——她可忘不了这个。 她在主函数前面停了下来，蜷着趴在键盘上。她觉得更冷了。她不敢回家，因为她还没调完二叉堆，没写对一个DP方程，教练一定会骂她的。再说，换成别的数据结构，一样写不出来。这些题都太水，虽然神犇都写过题解了，但是题解上一般都只有三个字：傻X题。 她几乎绝望了。啊，哪怕一个函数不会RE，对她也是有好处的！她每写一遍程序，跑出来的结果就不一样，要是她有数据，她就知道哪一个程序是算对了的。她得不到数据了，因为机房上不去网了，全校的网速都让隔壁的年级主任拿来下小电影了。如果能保证下一个程序能AC，她就敢再写几十KB的代码，但是她是不敢啊，她怕又算出来一个奇葩的结果来。 她新建了一个cpp重写了程序。编译通过了了，样例过了。这次，她感觉自己站在IOI的考场中AK。学校的大门上，贴着“我校学生以国际金牌向110周年校庆献礼”的条幅。在班级内的非诚勿扰中，全班男生都给她留了灯。这时候，程序又RE了，她面前只有cmd上的黑底白字。 她又写了一道模拟。这一回，她坐在美丽的二叉堆下。这棵二叉堆，比她在丽洁代码中看到的常数还要小，还要短。眼前是许多优美动人的ASCII码，那些都是她写的程序，各种可爱的指针在跳跃着，满世界都是系统栈，都在向她眨眼睛。小女孩向眼前的系统栈伸出手去。这时候，眼前的ASCII码还在，条幅还在，指针还在，年级主任还是和蔼地微笑着。只见那些代码那些指针越升越高越升越高，最后成了在天空中闪烁的星星。有一颗星星落下来了，在天空中划出了一道细长的红光。 “有一个什么人快要死了。”小女孩说。唯一疼她的学姐保送之前告诉过她：一颗星星落下来，就有一个灵魂要到上帝那儿去了。 她notepad++中又写了一个快排。这一回，她把能用的IDE都用了。学姐出现在亮光里，是那么温和，那么快乐。 “学姐！”小女孩叫起来，“啊！请把我带走吧！我知道，系统栈一溢出，您就会不见的，像那校门的条幅，浮点数的精度，循环队列的空间一个样，就会不见的！” 她赶紧编译了5KB的高精度模板，要把学姐留住。一大把程序发出强烈的光，把机房照得跟白天一样明亮。学姐从来没有像现在这样温柔，这样美丽。她把小女孩抱起来，搂在怀里。她们俩在光明和快乐中飞走了，越飞越高，飞到那没有DP，没有图论，也没有数据结构的地方去了。 第二天清晨，这个小女孩坐在机房里，两腮通红，嘴上带着微笑。她死了，在NOIP的前夜死了。NOIP Day1的太阳升起来了，照在她小小的尸体上。小女孩坐在那儿，显示器上还有一坨编译过的代码。 “她想好好复习复赛。”人们说。谁也不知道她曾经看到过多么美丽的东西，她曾经多么幸福，跟着她学姐一起走向新世界的幸福中去。 注：本文非本人（fanhy）所著，若有侵权请及时提醒，我将在第一时间更正。非常抱歉。]]></content>
      <categories>
        <category>notes</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1336 最佳课题选择 题解]]></title>
    <url>%2FLuogu-P1336%2F</url>
    <content type="text"><![CDATA[Problem题目描述Matrix67要在下个月交给老师$n$篇论文，论文的内容可以从$m$个课题中选择。由于课题数有限，Matrix67不得不重复选择一些课题。完成不同课题的论文所花的时间不同。具体地说，对于某个课题$i$，若Matrix67计划一共写$x$篇论文，则完成该课题的论文总共需要花费$A_i×x^{B_i}$个单位时间（系数$A_i$和指数$B_i$均为正整数）。给定与每一个课题相对应的$A_i$和$B_i$的值，请帮助Matrix67计算出如何选择论文的课题使得他可以花费最少的时间完成这$n$篇论文。 输入输出格式输入格式：第一行有两个用空格隔开的正整数$n$和$m$，分别代表需要完成的论文数和可供选择的课题数。 以下$m$行每行有两个用空格隔开的正整数。其中，第$i$行的两个数分别代表与第$i$个课题相对应的时间系数$A_i$和指数$B_i$。 输出格式：输出完成$n$篇论文所需要耗费的最少时间。 输入输出样例12345Input #110 32 11 22 1 12Output #119 样例说明：4篇论文选择课题一，5篇论文选择课题三，剩下一篇论文选择课题二，总耗时为$2×4^1+1×1^2+2×5^1=8+1+10=19$。可以证明，不存在更优的方案使耗时小于$19$。 Solution很简单的一道dp题。 虽然它长得像完全背包，但实质上是01背包。指数运算使得相同课题的耗时不能叠加，只能写3重循环来处理。这里背包中所有物品的大小都是1。 这道题求的是最小值，怎么办呢？将dp数组赋一个极大值，dp[0]=0，之后dp做的是min()而不是max()。 状态转移方程： 12//j是目前背包大小，k是写作篇数，cost是耗时f[j] = min(f[j], f[j - k] + cost); 另外，答案较大，需要开long long。 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 200 + 5;const int MAXM = 20 + 5;int n, m;int a[MAXM], b[MAXM];long long f[MAXN];long long Pow(int x, int y) //卡速米&#123; long long ret = 1, f = x; while(y &gt; 0) &#123; if(y &amp; 1) ret *= f; y &gt;&gt;= 1; f *= f; &#125; return ret;&#125;int main()&#123; for (int i = 1; i &lt; MAXN; i++) f[i] = 0x7fffffffff; //赋极大值 cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; i++) cin &gt;&gt; a[i] &gt;&gt; b[i]; for (int i = 1; i &lt;= m; i++) for (int j = n; j &gt;= 1; j--) for (int k = 1; k &lt;= j; k++) &#123; long long cost = a[i] * Pow(k, b[i]); //计算花费 f[j] = min(f[j], f[j - k] + cost); &#125; cout &lt;&lt; f[n] &lt;&lt; endl; return 0;&#125; Data评测请至洛谷P1336。]]></content>
      <categories>
        <category>solution</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P2756 飞行员配对方案问题 题解]]></title>
    <url>%2FLuogu-P2756%2F</url>
    <content type="text"><![CDATA[Problem题目描述英国皇家空军从沦陷国征募了大量外籍飞行员。由皇家空军派出的每一架飞机都需要配备在航行技能和语言上能互相配合的 2 名飞行员，其中 1 名是英国飞行员，另 1 名是外籍飞行员。在众多的飞行员中，每一名外籍飞行员都可以与其他若干名英国飞行员很好地配合。如何选择配对飞行的飞行员才能使一次派出最多的飞机。对于给定的外籍飞行员与英国飞行员的配合情况，试设计一个算法找出最佳飞行员配对方案，使皇家空军一次能派出最多的飞机。 对于给定的外籍飞行员与英国飞行员的配合情况，编程找出一个最佳飞行员配对方案，使皇家空军一次能派出最多的飞机。 输入输出格式输入格式：第 1 行有 2 个正整数$m$和$n$。$n$是皇家空军的飞行员总数$(n&lt;100)$；$m$是外籍飞行员数$(m&lt;=n)$。外籍飞行员编号为$1$ ~ $m$；英国飞行员编号为$m+1$ ~ $n$。 接下来每行有 2 个正整数$i$和$j$，表示外籍飞行员$i$可以和英国飞行员$j$配合。最后以2个-1结束。 输出格式：第 1 行是最佳飞行员配对方案一次能派出的最多的飞机数$M$。接下来$M$行是最佳飞行员配对方案。每行有 2个正整数$i$和$j$，表示在最佳飞行员配对方案中，飞行员$i$和飞行员$j$配对。如果所求的最佳飞行员配对方案不存在，则输出‘No Solution!’。 输入输出样例12345678910111213Input #15 101 71 82 62 92 103 73 84 74 85 10-1 -1 123456Output #141 72 93 85 10 Solution虽然是网络流的经典题，但由于我这个蒟蒻不会网络流，用匈牙利算法水过了。 乍一看，二分图匹配板子题，板子拉下来稍微改一下。 就这么过了 P.S.: 匈牙利算法模板可以参考这篇题解，里面写的还是很不错的。 与模板题唯一的不同之处在于，它要求输出配对方案。 由于我们在计算方案数的时候已经将match数组对应好了，最后无脑输出就可以了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 100 + 5;struct node&#123; int from, to, next;&#125;edge[MAXN * MAXN];int cnt, ans;int m, n, e;int a, b;int head[MAXN], lastt[MAXN], match[MAXN];void add(int a, int b)&#123; edge[++cnt].from = a; edge[cnt].to = b; edge[cnt].next = head[a]; head[a] = cnt;&#125;int iter(int p, int t)&#123; for(int i = head[p]; i; i = edge[i].next) &#123; int to = edge[i].to; if (lastt[to] != t) &#123; lastt[to] = t; if (!match[to] || iter(match[to], t)) &#123; match[to] = p; return true; &#125; &#125; &#125; return false;&#125;int main()&#123; cin &gt;&gt; m &gt;&gt; n; while(true) &#123; cin &gt;&gt; a &gt;&gt; b; if (a == -1 &amp;&amp; b == -1) break; add(a, b); &#125; for (int i = 1; i &lt;= m; i++) if (iter(i, i)) ans++; cout &lt;&lt; ans &lt;&lt; endl; for (int i = m + 1; i &lt;= n; i++) if (match[i]) cout &lt;&lt; match[i] &lt;&lt; ' ' &lt;&lt; i &lt;&lt; endl; return 0;&#125; Data提交请至洛谷P2756。]]></content>
      <categories>
        <category>solution</category>
      </categories>
      <tags>
        <tag>Luogu</tag>
        <tag>网络流24题</tag>
        <tag>二分图</tag>
        <tag>匈牙利算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LMIO2012 cechas 题解]]></title>
    <url>%2FLMIO2012-cechas%2F</url>
    <content type="text"><![CDATA[Problem问题描述：Linas的工厂需要安装微控制器与多台设备连接，以便设备之间交流控制信息。同微控制器连接的每台设备都单独使用一根电缆连接，工厂是长方形形状。所有电缆平行坐标轴铺设，左下角坐标$(0,0)$。 输入Linas每台设备的坐标和该设备电缆的单位费用。 任务:请你编写一个程序，请帮助Linas计算安装微控制器的位置坐标，使连接所有设备的电缆花费最少。 输入格式：第一行包含一个整数$n(1≤n≤10^6)$。表示要连接的设备有$n$台。 以下$n$行，第$i$行$3$个整数$X_i,Y_i,k_i(0≤X_i,Yi≤10^6, 1≤Ki≤10^6)$，分别表示第$i$台设备的坐标，该设备电缆的单位费用。可以多台设备共线(图中粗线)。 输出格式：第一行是两个整数$X,Y$安装微控制器的位置坐标。第二行最小电缆费用。如果有多个答案，输出$1$个即可。 样例输入输出：1234567Input #151 1 34 1 31 2 32 4 34 4 3 123Output #12 236 样例1解释：12345678910Input #281 1 41 2 21 3 23 4 14 4 15 5 16 6 47 6 3 123Output #23 476 样例2解释： Solution这道题应将横纵坐标分开讨论。 可以想到，一台单价为$k$的设备和$k$台单价为1的设备是等价的。 设微处理器横坐标为$x$,$n$台设备的坐标为$X$。这里的n指处理完后单价为1的设备的数量。 则横向上总价可以表示成： $\sum\limits_{i=1}^n{|x-X_i|}$ 于是由绝对值的几何意义（亦可以说均值不等式），将x升序排列后得： 若$n$为奇数, 则$x=X_{\frac{n+1}{2}}$; 若$n$为偶数, 则$x∈[X_{\frac{n}{2}},X_{\frac{n}{2}+1}]$。 代码： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 1000000 + 5;struct node&#123; int x, y, c; &#125;app[MAXN];int n, x, y;long long sum, cnt, half;unsigned long long cost;int i;unsigned long long Abs(int c, int d) &#123; return c &gt; d ? c - d : d - c; &#125;bool cmpx(node a, node b) &#123; return a.x &lt; b.x; &#125;bool cmpy(node a, node b) &#123; return a.y &lt; b.y; &#125;int main()&#123; cin &gt;&gt; n; for (i = 1; i &lt;= n; i++) cin &gt;&gt; app[i].x &gt;&gt; app[i].y &gt;&gt; app[i].c, sum += app[i].c; half = ceil(double(sum) / 2); sort(app + 1, app + n + 1, cmpx); for (i = 1; i &lt;= n; i++) &#123; cnt += app[i].c; if (cnt &gt;= half) break; &#125; x = app[i].x; cnt = 0; sort(app + 1, app + n + 1, cmpy); for (i = 1; i &lt;= n; i++) &#123; cnt += app[i].c; if (cnt &gt;= half) break; &#125; y = app[i].y; cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; endl; for (i = 1; i &lt;= n; i++) cost += (Abs(app[i].x, x) + Abs(app[i].y, y)) * app[i].c; cout &lt;&lt; cost &lt;&lt; endl; return 0;&#125; Data测试数据提取码：vf80]]></content>
      <categories>
        <category>solution</category>
      </categories>
      <tags>
        <tag>LMIO</tag>
        <tag>2012</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CEOI2009 logs 题解]]></title>
    <url>%2FCEOI2009-logs%2F</url>
    <content type="text"><![CDATA[Problem问题简述：有一个$n×m$的01矩阵，现在你可以的任意交换其中的列，要求找一个最大的仅由1组成的矩阵。 输入格式：第一行包含两个整数$n(1≤n≤15000)$和$m(1≤m≤1500)$，表示矩阵的大小。 接下来$n$行，每行$m$个字符$0$或$1$。 输出格式：一个最大的仅由$1$组成的矩阵面积。 样例输入输出：123456789101112Input #110 6001010111110011110111110011110111111110111110111000101010101 12Output #121 限制时间限制0.6秒 空间限制64MB Solution算法这道题看起来复杂，事实上比不能交换列还简单。 先来考虑一行的情况。 显然，由于列可以自由交换，有多少个$1$矩阵就有多大。 可以理解为，把所有的$0$扔到最后，统计前面$1$的个数。 然后考虑两行。 仿照一行的做法，把所有上下全为$0$的往后扔，上下全为$1$的往前扔。 由于我们的目标是把能与下一行组成矩阵的列往前放，而 上$1$下$0$ 显然不符合这个要求，$0$在下面就隔绝了上方矩形继续升长的路。 所以把$01$放在$11$后面，$10$前面。 至于$10$和$00$之间的顺序，它们已经对之后的操作没有意义了，所以这不重要。 下面是一个例子。 如果输入长这样： 1210110101100110 处理完后就变成： 1211001101111000 可以清楚地看到最大矩阵大小为$4$。 其实处理时，我们需要的只有： 12111111 如果行数$≥3$，那么就按每一列下方有多少个连续的$1$降序排序。 于是每一个输入都可以变成类似于 12345671111111111111111111111111111111111111 的样子，接下来要求最大子矩阵就很方便了。 注意：处理完后的矩阵每行长度不一定升序，但这并不影响最后的结果 代码代码对之前的算法略作改进，详见注释。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXM = 1500 + 5;int n, m, ans;int q[2][MAXM], depth[MAXM];//q是滚动数组，用来记录上一次排序好后列的编号//depth用来记录当前每一列连续1的长度int front, top;bool x;char ch;int main()&#123; cin &gt;&gt; n &gt;&gt; m; //未经处理时，每一列都一样，q的数值就是自己的下标 for (int i = 1; i &lt;= m; i++) q[0][i] = i; for (int i = 1; i &lt;= n; i++) &#123; front = 0; ch = getchar(); //吃掉换行 x ^= 1; //滚动 for (int j = 1; j &lt;= m; j++) &#123; ch = getchar(); if (ch == '1') depth[j]++; //如果是1，深度+1 else depth[j] = 0; //如果是0，之前无论多少个1都不会对后面产生影响，深度记为0 &#125; for (int j = 1; j &lt;= m; j++) if ( depth[q[x ^ 1][j]]) q[x][++front] = q[x ^ 1][j]; //如果这一列为1，那么一定排在0前面 //从第1列排序好后，q数组记录的编号就是按深度降序排列了 //因为先访问的是已经有1了的，所以越早获得1就排在越前面，晚获得1只能排在之前就获得了1的后面 top = front; //depth&gt;0的最后一列的编号，计算ans时不需要depth=0的列 //把深度为0的塞进去 for (int j = 1; j &lt;= m; j++) if (!depth[q[x ^ 1][j]]) q[x][++front] = q[x ^ 1][j]; //从后往前搜可以优化 for (int j = top; j &gt;= 1; j--) if (j &lt; top &amp;&amp; depth[q[x][j]] == depth[q[x][j + 1]]) continue; //一点小优化，深度和你一样，宽度还比你长，面积一定比你大 else ans = max(ans, j * depth[q[x][j]]); //更新答案 &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 后记问题来了，这道题长得不像悬线法啊？ 是的，但可以理解为$left=1,right=\text{排序后列数}$的悬线。 Data暂无测试数据QAQ]]></content>
      <categories>
        <category>solution</category>
      </categories>
      <tags>
        <tag>CEOI</tag>
        <tag>2009</tag>
        <tag>悬线法</tag>
        <tag>滚动数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CEOI1995 stick 题解]]></title>
    <url>%2FCEOI1995-stick%2F</url>
    <content type="text"><![CDATA[Problem问题描述：乔治有一些同样长的小木棍，他把这些木棍随意砍成几段，直到每段的长都不超过$50$。 现在，他想把小木棍拼成原来的样子，但是却忘记了自己开始时有多少根木棍和它们的长度。 给出每段小木棍的长度，编程帮他找出原始木棍的最小可能长度。 输入：输入文件共有二行。第一行为一个单独的整数$n$表示砍过以后的小木棍的总数，其中$n≤64$，第二行为$n$个用空格隔开的正整数，表示$n$根小木棍的长度。 输出：输出文件仅第一行，表示原始木棍的最小可能长度。 输入输出样例：123Input #195 2 1 5 2 1 5 2 1 12Output #16 Solution显然这是一道搜索题。 由于每根原始木棍长度一样，所以答案必然能整除所有木棍总长度，并且不能比最长的那一根短。 搜索的结束条件是 剩下的木棍根数 $=0$ 且 当前原始木棍剩余长度 $=0$。 如果 当前原始木棍剩余长度 $=0$，那么之后的木棍就应放到下一根里去。 具体剪枝方案见代码注释。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 65;int n;int a[MAXN], sum;int all; //初始长度bool Visit[MAXN];bool cmp(int x, int y) &#123; return x &gt; y; &#125;bool dfs(int last, int left, int depth) //last表示上一次用了哪一根，由于已经排过序，这一次取的木棍一定比上一次短&#123; if (depth == 0 &amp;&amp; left == 0) return true; //搜完了，满足条件 if (depth == 0 &amp;&amp; left != 0) return false; //搜完了但不满足条件 if (left == 0) left = all, last = 1; //这根填满了，重置下一根 for (int i = last; i &lt;= n; i++) if (a[i] &lt;= left) &#123; if (Visit[i]) continue; //已经用过了 if (i &gt; 1 &amp;&amp; !Visit[i - 1] &amp;&amp; a[i] == a[i - 1]) continue; //如果上一根和这一根长度一样，也没能成功，这一根可以不搜 Visit[i] = true; //标记为已访问 if (dfs(i, left - a[i], depth - 1)) return true; //递归搜下一根 Visit[i] = false; //回溯 if (a[i] == left || left == all) return false; /* 已知放这根木棍不成功，那么分两类讨论： 1.若放好这一根正好能填满当前原始木棍，而剩下的木棍无法填满之后的原始木棍，则之后搜的结果和本次搜的一样，都无法完成，回溯； 2.若当前原始木棍是一根新木棍，则亦无法完成，原因同上。 这层剪枝十分重要，但较为难想。 */ &#125; return false;&#125;int main()&#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i], sum += a[i]; sort(a + 1, a + n + 1, cmp); for (int i = a[1]; i &lt;= sum / 2; i++) if(sum % i == 0) //能整除 &#123; all = i; if (dfs(1, i, n)) &#123; cout &lt;&lt; i &lt;&lt; endl; return 0; &#125; &#125; //找到答案 cout &lt;&lt; sum &lt;&lt; endl; return 0;&#125; Data测试数据 提取码：3gag 无注释代码也一起放了进去，供大家参考。]]></content>
      <categories>
        <category>solution</category>
      </categories>
      <tags>
        <tag>搜索</tag>
        <tag>DFS</tag>
        <tag>CEOI</tag>
        <tag>1995</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Balkan2008 closest 题解]]></title>
    <url>%2FBalkan2008-closest%2F</url>
    <content type="text"><![CDATA[Problem问题描述：有两个没有前导$0$的$n$位十进制数$A$和$B$。我们需要找到两个最接近$A$的$n$位数(第1个大于等于$A$，第二小于$A$)，包含B的所有数字。 例如，如果$A=3022$，$B=1232$，采用$B$的数字，我们可以得到以下$4$位数:$1223$，$1232$，$1322$，$2123$，$2132$，$2213$，$2231$，$2312$，$2321$，$3122$，$3212$和$3221$。 最小的大于等于$A$是$3122$，最大小于$A$的是$2321$。 如果$A=1232$，而$B=3022$，可能的$4$位数是$2023$，$2032$，$2203$，$2230$，$2302$，$2320$，$3022$，$3202$和$3220$。 最小的大于等于$A$是$3122$，最大小于$A$的是$2023$。不存在小于$4$的数。 编写程序，对于给定的$A$和$B$，找出最接近$A$的包含$B$的所有数字的数，或者确定其中一个是不存在的。 输入格式：输入两行，都是没有前导$0$的$n(1≤n≤60)$位正整数，第一行是$A$，第二行是$B$。 输出格式：输出两行，每行一个十进制数。 第1行是最小的大于等于$A$的没有前导$0$的，包含$B$所有数字的$n$位十进制数。如果这样的数不存在，则输出$0$。 第2行是最大的小于$A$的没有前导$0$的，包含$B$所有数字的$n$位十进制数。如果这样的数不存在，则输出$0$。 样例输入输出：123Input #130756604 123Output #140660 123Input #230002034562454 123Output #242445562655444 Solution本题难度不高。 很容易想到，既然越接近越好，那么就一位一位匹配，能匹配上就用，如果发现完成不了回溯就行了。 这题主要是注意下细节，调试可能比较烦，算法很简单，耐心做就OK了。 具体算法详见代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;using namespace std;string a, b;int len;int cntl[10], cntr[10];bool found;int last;int ans[65];bool dfs1(int s, int depth)&#123; if (depth == len) return false; int start = 0; bool fail = true; int now = a[depth] - '0'; if (s) start = now; for (int i = start; i &lt;= 9; i++) if (cntl[i]) &#123; cntl[i]--, ans[depth] = i; if(i == start &amp;&amp; s) s = 1; else s = 0; fail = dfs1(s, depth + 1); if (fail) cntl[i]++; else &#123;fail = false; break;&#125; &#125; return fail;&#125;bool dfs2(int s, int depth)&#123; if (depth == len) return false; int start = 9; bool fail = true; int now = a[depth] - '0'; if (s) &#123; start = now; if (depth == len - 1) start--; &#125; for (int i = start; i &gt;= 0 + (!depth); i--) if (cntr[i]) &#123; cntr[i]--, ans[depth] = i; if(i == start &amp;&amp; s) s = 1; else s = 0; fail = dfs2(s, depth + 1); if (fail) cntr[i]++; else &#123;fail = false; break;&#125; &#125; return fail;&#125;int main()&#123; cin &gt;&gt; a &gt;&gt; b; len = a.length(); for (int i = 0; i &lt; len; i++) cntl[b[i] - '0']++, cntr[b[i] - '0']++; if (dfs1(1, 0)) cout &lt;&lt; "0"; else for (int i = 0; i &lt; len; i++) cout &lt;&lt; ans[i]; cout &lt;&lt; endl; if (dfs2(1, 0)) cout &lt;&lt; "0"; else for (int i = 0; i &lt; len; i++) cout &lt;&lt; ans[i]; cout &lt;&lt; endl; return 0;&#125; Data评测请至洛谷SP3889。]]></content>
      <categories>
        <category>solution</category>
      </categories>
      <tags>
        <tag>搜索</tag>
        <tag>Balkan</tag>
        <tag>2008</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BOI2013 tracks in the snow 题解]]></title>
    <url>%2FBOI2013-tracks-in-the-snow%2F</url>
    <content type="text"><![CDATA[ProblemDescribeThere is a rectangular meadow in a forest, having been covered with a blanket of fresh snow in themorning (left in the figure below). Rabbits and foxes, who live in the forest, are crossing the meadow and leave their tracks in the snow. They always enter in the upper left corner and leave the meadow from the lower right corner. In between they can move back and forth, playing in the snow, even crossing their own tracks. At anytime there is at most one animal on the meadow. No animal enters the meadow more than once. The movements of the animals can be described by dividing the meadow into quadratic cells. The animals never move diagonally in a single step and they never jump over a cell. When an animal enters a cell its tracks will cover all previous tracks left in this cell.For example, first a rabbit crossed the meadow from top-left to bottom-right (middle in the figure).After that, a fox crossed, and now his tracks are partially covering the rabbit’s (right in the figure). 12345........ RRR..... FFR............. ..RRR... .FRRR........... ..R..... .FFFFF.......... ..RRRR.R ..RRRFFR........ .....RRR .....FFF You are given a map of the meadow at some time after indicating for each cell if there are any visible tracks and whether they were left by a rabbit or by a fox (right in the figure). You are interested in the local wildlife population. Write a program to determine the minimal possible number N of animals that must have crossed the meadow to leave the given pattern of tracks in the snow. InputThe first line contains two integers H and W, the height and the width of the map of the meadow. H lines follow with exactly W characters on each: the map, where ‘.’ marks untouched snow, ‘R’ a spot where a rabbit’s track is the topmost one, and ‘F’ a spot where a fox’s track is the topmost one. There is at least one track on the meadow. OutputThe output should consist of a single integer: the minimal number N ≥ 1 of animals that could have left the tracks given in the input. Constraints1 ≤ H, W ≤ 4000In test cases worth 30 points: N ≤ 200 and H, W ≤ 500 Example1234567Input #15 8 FFR......FRRR....FFFFF....RRRFFR.....FFF 12Output #12 LimitsTime limit: 2 sec per test case Memory limit: 1300 MB per test case Solution注意到测试数据保证有解。 主要题干已经加粗。 暴力标签里的BFS已经明示了这是一道搜索题。 题目里很重要的一条信息是脚印可以覆盖。 于是可以想到，如果两只动物交替走，那么后一次动物走过的地方即使上一次动物可以走的地方。 我们可以将走过的动物脚印全部都变为另外一种动物的脚印，这样下来，如果全屏只有一只动物的脚印，那么就说明不需要再有别的动物走了。 因为每一次反色都代表了一只动物走过，所以答案就是 运行次数+1。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//TLE code#include &lt;bits/stdc++.h&gt;using namespace std;const int dx[4] = &#123; -1, 0, 1, 0 &#125;;const int dy[4] = &#123; 0, 1, 0, -1 &#125;;const int MAXN = 4000 + 5;char ch;int n, m;int g[MAXN][MAXN];bool Visit[MAXN][MAXN];queue&lt;pair&lt;int, int&gt; &gt; Q;int ans;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; ch = getchar(); for (int j = 1; j &lt;= m; j++) &#123; ch = getchar(); switch (ch) &#123; case 'R': g[i][j] = 0; break; case '.': g[i][j] = -1; break; case 'F': g[i][j] = 1; break; &#125; &#125; &#125; while (true) &#123; for (int i = 0; i &lt;= n + 1; i++) for (int j = 0; j &lt;= m + 1; j++) Visit[i][j] = false; ans++; Q.push(make_pair(1, 1)); while (!Q.empty()) &#123; pair&lt;int, int&gt; now = Q.front(); Q.pop(); int x = now.first, y = now.second; Visit[x][y] = true; for (int i = 0; i &lt; 4; i++) &#123; int fx = x + dx[i], fy = y + dy[i]; if (fx &lt; 1 || fy &lt; 1 || fx &gt; n || fy &gt; m || g[x][y] != g[fx][fy] || Visit[fx][fy]) continue; Q.push(make_pair(fx, fy)); &#125; &#125; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) if (Visit[i][j]) g[i][j] = 1 - g[i][j]; bool ra = false, fo = false; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) &#123; if (g[i][j] == 0) ra = true; else if (g[i][j] == 1) fo = true; &#125; if (!(ra &amp;&amp; fo)) break; &#125; cout &lt;&lt; ans + 1 &lt;&lt; endl; return 0;&#125; 交上去一看，T飞了，第二个点就跑了9s。 因此我们需要对这个算法进行一点优化 优化之所以会TLE，对于循环退出的判断占了很大一部分。并且，我们在搜索过程中，反复经过已经走过的位置，这样效率便很低。 因为走过的部分一定可以再走，所以我们只需要考虑没走过的部分。 优化后的算法变成了“填棋盘”，即整个棋盘只走一遍，大大提高了效率。 对于循环退出的判断也优化了很多，详见代码。 （注：这份代码在本机上测最慢的点跑了将近4s，如果还有优化请在评论区回复，感谢您的贡献） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;using namespace std;const int dx[4] = &#123; -1, 0, 1, 0 &#125;;const int dy[4] = &#123; 0, 1, 0, -1 &#125;;const int MAXN = 4000 + 5;char ch;int n, m;bool g[MAXN][MAXN];bool Visit[MAXN][MAXN];queue&lt;pair&lt;int, int&gt; &gt; Q[2];int ans;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; ch = getchar(); for (int j = 1; j &lt;= m; j++) &#123; ch = getchar(); switch (ch) &#123; case 'R': g[i][j] = 0; break; case '.': Visit[i][j] = true; break; case 'F': g[i][j] = 1; break; &#125; &#125; &#125; Q[0].push(make_pair(1, 1)); Q[0].push(make_pair(n, m)); int k = 0; while (!Q[k].empty()) &#123; while (!Q[k].empty()) &#123; pair&lt;int, int&gt; now = Q[k].front(); Q[k].pop(); int x = now.first, y = now.second; if (Visit[x][y]) continue; Visit[x][y] = true; for (int i = 0; i &lt; 4; i++) &#123; int fx = x + dx[i], fy = y + dy[i]; if (fx &lt; 1 || fy &lt; 1 || fx &gt; n || fy &gt; m || Visit[fx][fy]) continue; if (g[x][y] ^ g[fx][fy]) Q[1 - k].push(make_pair(fx, fy)); else Q[k].push(make_pair(fx, fy)); &#125; &#125; k = 1 - k; ans++; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; Data测试数据 提取码：3vm2]]></content>
      <categories>
        <category>solution</category>
      </categories>
      <tags>
        <tag>BOI</tag>
        <tag>2013</tag>
        <tag>BFS</tag>
        <tag>反色</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
</search>
