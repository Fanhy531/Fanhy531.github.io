<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[friends]]></title>
    <url>%2Ffriends%2F</url>
    <content type="text"><![CDATA[%%%orz以下所有吊打我的大佬：memset0 redbag M-sea rqy lxy]]></content>
      <categories>
        <category>Intro</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[类别索引]]></title>
    <url>%2Fcategory%2F</url>
    <content type="text"><![CDATA[介绍题解]]></content>
      <categories>
        <category>system</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[标签索引]]></title>
    <url>%2Ftag%2F</url>
    <content type="text"><![CDATA[题库标签BOI 年份标签2013 算法标签BFS 反色]]></content>
      <categories>
        <category>system</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[BOI2013 tracks in the snow 题解]]></title>
    <url>%2FBOI2013-tracks-in-the-snow%2F</url>
    <content type="text"><![CDATA[ProblemDescribeThere is a rectangular meadow in a forest, having been covered with a blanket of fresh snow in themorning (left in the figure below). Rabbits and foxes, who live in the forest, are crossing the meadow and leave their tracks in the snow. They always enter in the upper left corner and leave the meadow from the lower right corner. In between they can move back and forth, playing in the snow, even crossing their own tracks. At anytime there is at most one animal on the meadow. No animal enters the meadow more than once. The movements of the animals can be described by dividing the meadow into quadratic cells. The animals never move diagonally in a single step and they never jump over a cell. When an animal enters a cell its tracks will cover all previous tracks left in this cell.For example, first a rabbit crossed the meadow from top-left to bottom-right (middle in the figure).After that, a fox crossed, and now his tracks are partially covering the rabbit’s (right in the figure). 12345........ RRR..... FFR............. ..RRR... .FRRR........... ..R..... .FFFFF.......... ..RRRR.R ..RRRFFR........ .....RRR .....FFF You are given a map of the meadow at some time after indicating for each cell if there are any visible tracks and whether they were left by a rabbit or by a fox (right in the figure). You are interested in the local wildlife population. Write a program to determine the minimal possible number N of animals that must have crossed the meadow to leave the given pattern of tracks in the snow. InputThe first line contains two integers H and W, the height and the width of the map of the meadow. H lines follow with exactly W characters on each: the map, where ‘.’ marks untouched snow, ‘R’ a spot where a rabbit’s track is the topmost one, and ‘F’ a spot where a fox’s track is the topmost one. There is at least one track on the meadow. OutputThe output should consist of a single integer: the minimal number N ≥ 1 of animals that could have left the tracks given in the input. Constraints1 ≤ H, W ≤ 4000In test cases worth 30 points: N ≤ 200 and H, W ≤ 500 Example1234567Input Output5 8 2FFR......FRRR....FFFFF....RRRFFR.....FFF LimitsTime limit: 2 sec per test case Memory limit: 1300 MB per test case Solution注意到测试数据保证有解。 主要题干已经加粗。 暴力标签里的BFS已经明示了这是一道搜索题。 题目里很重要的一条信息是脚印可以覆盖。 于是可以想到，如果两只动物交替走，那么后一次动物走过的地方即使上一次动物可以走的地方。 我们可以将走过的动物脚印全部都变为另外一种动物的脚印，这样下来，如果全屏只有一只动物的脚印，那么就说明不需要再有别的动物走了。 因为每一次反色都代表了一只动物走过，所以答案就是 运行次数+1。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//TLE code#include &lt;bits/stdc++.h&gt;using namespace std;const int dx[4] = &#123; -1, 0, 1, 0 &#125;;const int dy[4] = &#123; 0, 1, 0, -1 &#125;;const int MAXN = 4000 + 5;char ch;int n, m;int g[MAXN][MAXN];bool Visit[MAXN][MAXN];queue&lt;pair&lt;int, int&gt; &gt; Q;int ans;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; ch = getchar(); for (int j = 1; j &lt;= m; j++) &#123; ch = getchar(); switch (ch) &#123; case 'R': g[i][j] = 0; break; case '.': g[i][j] = -1; break; case 'F': g[i][j] = 1; break; &#125; &#125; &#125; while (true) &#123; for (int i = 0; i &lt;= n + 1; i++) for (int j = 0; j &lt;= m + 1; j++) Visit[i][j] = false; ans++; Q.push(make_pair(1, 1)); while (!Q.empty()) &#123; pair&lt;int, int&gt; now = Q.front(); Q.pop(); int x = now.first, y = now.second; Visit[x][y] = true; for (int i = 0; i &lt; 4; i++) &#123; int fx = x + dx[i], fy = y + dy[i]; if (fx &lt; 1 || fy &lt; 1 || fx &gt; n || fy &gt; m || g[x][y] != g[fx][fy] || Visit[fx][fy]) continue; Q.push(make_pair(fx, fy)); &#125; &#125; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) if (Visit[i][j]) g[i][j] = 1 - g[i][j]; bool ra = false, fo = false; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) &#123; if (g[i][j] == 0) ra = true; else if (g[i][j] == 1) fo = true; &#125; if (!(ra &amp;&amp; fo)) break; &#125; cout &lt;&lt; ans + 1 &lt;&lt; endl; return 0;&#125; 交上去一看，T飞了，第二个点就跑了9s。 因此我们需要对这个算法进行一点优化 优化之所以会TLE，对于循环退出的判断占了很大一部分。并且，我们在搜索过程中，反复经过已经走过的位置，这样效率便很低。 因为走过的部分一定可以再走，所以我们只需要考虑没走过的部分。 优化后的算法变成了“填棋盘”，即整个棋盘只走一遍，大大提高了效率。 对于循环退出的判断也优化了很多，详见代码。 （注：这份代码在本机上测最慢的点跑了将近4s，如果还有优化请在评论区回复） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;using namespace std;const int dx[4] = &#123; -1, 0, 1, 0 &#125;;const int dy[4] = &#123; 0, 1, 0, -1 &#125;;const int MAXN = 4000 + 5;char ch;int n, m;bool g[MAXN][MAXN];bool Visit[MAXN][MAXN];queue&lt;pair&lt;int, int&gt; &gt; Q[2];int ans;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; ch = getchar(); for (int j = 1; j &lt;= m; j++) &#123; ch = getchar(); switch (ch) &#123; case 'R': g[i][j] = 0; break; case '.': Visit[i][j] = true; break; case 'F': g[i][j] = 1; break; &#125; &#125; &#125; Q[0].push(make_pair(1, 1)); Q[0].push(make_pair(n, m)); int k = 0; while (!Q[k].empty()) &#123; while (!Q[k].empty()) &#123; pair&lt;int, int&gt; now = Q[k].front(); Q[k].pop(); int x = now.first, y = now.second; if (Visit[x][y]) continue; Visit[x][y] = true; for (int i = 0; i &lt; 4; i++) &#123; int fx = x + dx[i], fy = y + dy[i]; if (fx &lt; 1 || fy &lt; 1 || fx &gt; n || fy &gt; m || Visit[fx][fy]) continue; if (g[x][y] ^ g[fx][fy]) Q[1 - k].push(make_pair(fx, fy)); else Q[k].push(make_pair(fx, fy)); &#125; &#125; k = 1 - k; ans++; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 是不是又短又快呢？ 最后附上测试数据 提取码：3vm2]]></content>
      <categories>
        <category>solution</category>
      </categories>
      <tags>
        <tag>BOI</tag>
        <tag>2013</tag>
        <tag>BFS</tag>
        <tag>反色</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于]]></title>
    <url>%2Fabout%2F</url>
    <content type="text"><![CDATA[这里是蒟蒻fanhy的博客。 本人是G2017 SH OIer, 六年级开始跳OI这个坑，现在已经爬不出来了QAQ 微小的成就： year prize 2018 NOIPpj一等奖 欢迎大佬前来虐菜。 我的洛咕账号 以下全部ORZ%%%： 大佬同学 同校神犇 无敌巨佬]]></content>
      <categories>
        <category>Intro</category>
      </categories>
  </entry>
</search>
